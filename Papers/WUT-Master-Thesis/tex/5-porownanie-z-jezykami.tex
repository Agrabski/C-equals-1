\section{Porównanie z innymi językami}
Ponieważ C-=-1 jest językiem badawczym, nie można go porównywać z językami stosowanymi w przemyśle pod względem wygody użycia.
Warto jednak przeanalizować, w jaki sposób zaproponowane mechanizmy wpływają na jego użyteczność.

\subsection{Wsparcie dla paradygmatów programowania}
Teoretycznie niemalże w każdym języku da się programować w każdym paradygmacie. Jednak w zależności od jego, może być to zadanie prostsze lub trudniejsze. 

\subsubsection{Aspect Oriented Programming}
Nieoczekiwanym skutkiem zaproponowanych mechanizmów jest wsparcie dla programowania aspektowego (Aspect Oriented Programming, AOP).

\subsubsection{Obiektowe}
C-=-1 został zaprojektowany z myślą o wsparciu stylu obiektowego. Użytkownik może deklarować typy, metody oraz interfejsy. W przeciwieństwie do C++ czy C\#, w C-=-1 nie ma jednak koncepcji dziedziczenia między konkretnymi klasami.

Klasy i interfejsy mogą implementować inne interfejsy.
To jest jedyny mechanizm dynamicznego polimorfizmu w C-=-1.
Ta decyzja została podjęta częściowo w celu uproszczenia języka, a częściowo, ponieważ dziedziczenie między konkretnymi klasami jest uważane za złą praktykę \cite{gang_of_four:design_patterns}.

\subsection{Analiza kodu}
Podstawowym celem C-=-1 było zbadanie możliwości statycznej analizy kodu, używając zaproponowanych mechanizmów metaprogramowania.
W kolejnych rozdziałach omówione zostaną przykładowe analizatory, które zostały zaimplementowane w ramach biblioteki standardowej bądź których implementacja jest możliwa.
Ma to zademonstrować praktyczne aplikacje udostępnienia programiście modelu semantycznego tworzonego programu.



\subsubsection{Atrybut noDiscard}
\label{no_discard}

Atrybut \lstinline{noDiscard} służy do zapewnienia, że wynik funkcji nie zostanie zignorowany.
Tego typu adnotacja istnieje w C++ od wersji 17\cite{ISO:cpp17}.
Ma on na celu wyeliminować błędy takie jak ignorowanie kodu błędu, czy niepoprawne wywołanie funkcji o mylącej nazwie.

W C-=-1, w przeciwieństwie do większości języków niskiego poziomu, stworzenie analizatora, który zapewnia taki niezmiennik, jest trywialne.
Listing \ref{lst:noDiscardCm1} zawiera kod atrybutu \lstinline{noDiscard} z biblioteki standardowej C-=-1.
Na linii 4 deklaruje on specjalną funkcję \lstinline{onCall} (specjalne funkcje atrybutów zostały opisane w rozdziale \ref{Attributes_mechanism_cm1}), która reaguje na wywołanie funkcji, do której został zaaplikowany.

Wewnątrz tego podprogramu, atrybut sprawdza, czy bezpośrednim rodzicem tego wyrażenia jest wyrażenie, czy instrukcja.
Jeśli jest nim instrukcja, oznacza to że wynik wywołania jest ignorowany i trzeba zgłosić błąd, używając funkcji \lstinline{raiseError}.
W przeciwnym wypadku żadne akcje nie są konieczne.

Listing \ref{lst:noDiscardUsageCm1} demonstruje zastosowanie atrybut \lstinline{noDiscard}.
Zignorowanie wartości zwracanej przez funkcję oznaczoną tą adnotacją, tak jak na linii 5, powoduje zgłoszenie błędu o kodzie i komunikacie zgodnym z linią 7 listingu \ref{lst:noDiscardCm1}.
Ponadto, kompilator otrzymuje wskazanie do pliku źródłowego na punkt, który wywołał ten błąd.
Ta informacja może być potem użyta do zaprezentowania programiście dokładniejszej diagnostyki bądź do podkreślenia kodu w zintegrowanym środowisku programistycznym (rozdział \ref{IDE_integration}).

Ten przykład dobrze ilustruje, że mając dostęp do modelu semantycznego programu, implementacja niektórych typów analizy staje się trywialna.
W większości języków programowania taka analiza wymaga modyfikacji kompilatora albo zewnętrznego narzędzia.

\begin{minipage}{\linewidth}
  
  \begin{lstlisting}[
    numbers=left,
    firstnumber=0,
    caption={Atrybut noDiscard w C-=-1},
    aboveskip=0pt,
    label={lst:noDiscardCm1}
    ]
public att<function> NoDiscard
{
  public fn attach(f: functionDescriptor)
  {}
  public fn onCall(call: functionCallExpression*)
  {
  if(call._parentStatment != null<IInstruction>())
    raiseError(
      &(call._pointerToSource), 
      "Return value of a no-discard function is not used",
      123
    );
  }
}
\end{lstlisting}
\end{minipage}


\begin{minipage}{\linewidth}
  
  \begin{lstlisting}[
    numbers=left,
    firstnumber=0,
    caption={Przykład użycia atrybut noDiscard w C-=-1},
    aboveskip=0pt,
    label={lst:noDiscardUsageCm1}
    ]
[noDiscard()]
fn noDiscardFunction() -> usize;

fn main() -> usize
{
  noDiscardFunction(); // error 123: Return value of
                       // a no-discard function is not use
  let x = noDiscardFunction();     // ok
  let y = x + noDiscardFunction(); // ok
  return noDiscardFunction();      // ok
}
\end{lstlisting}
\end{minipage}

\subsubsection{Atrybut const}
\label{const}

Bardziej złożonym przykładem analizatora, jest atrybut \lstinline{const}.
Odpowiada on modyfiaktorowi \lstinline{const} z języka C++.
Zaaplikowanie go do typu oznacza, że do jego instancja jest niemodyfikowalna.
Każda próba modyfikacji, po zainicjalizowaniu, jest błędem.

W obecnym stanie kompilatora oraz języka, możliwa jest implementacja części tej funkcjonalności.
Pełne wsparcie dla tego modyfikatora, przy użyciu atrybutu, wymaga od C-=-1 następujących właściwości:
\begin{enumerate}
  \item \label{prop:Attribute_function_overloading} Atrybuty są brane pod uwagę w trakcie wyboru przeciążenia funkcji
  \item \label{prop:Generic_adnotations} Istnieje sposób na modyfikowanie zachowania zmiennych, pól i parametrów w generykach, przy tworzeniu ich instancji
  \item \label{prop:Reference_adnotations} Przy aplikowaniu atrybutu do zmiennej typu referencyjnego, istnieje sposób na rozróżnienie między stałym wskazaniem a wskazaniem na stałą.
\end{enumerate}

Właściwość \ref{prop:Attribute_function_overloading} częściowo zaplanowaną, ale niezrealizowaną częścią języka (rozdział \ref{Attributes_definition}).
Atrybuty powiązane z parametrami deklaracji mają być traktowane jako wymagania na wartościach przekazywanych przy wywołaniu funkcji.
Ta potrzeba wywodzi się z tego, że dokładne znaczenie danej operacji w jest zależne od modyfikatorów zaaplikowanych do używanych wartości. %todo: wording. example
Wymaga to dalszego rozszerzenia systemu atrybutów, tak aby można było aplikować adnotacje do wartości zwracanych z funkcji.


Zapewnienie właściwości \ref{prop:Generic_adnotations}, jest najtrudniejsze i wymaga dalej idącej pracy teorytycznej.
Zaaplikowanie systemu atrybutów do implementacji modyfikatora \lstinline{const} oznacza śledzenie wartości, nie koniecznie pól, zmiennych, typów czy funkcji.
Listing \ref{lst:const_problem_example} przedstawia problem rozwiązywany przez właściwość \ref{prop:Generic_adnotations}.
Na linii 2, deklarowana jest zmienna typu \lstinline{usize} z modyfikatorem \lstinline{const}.
Następnie, na linii 4, wskazanie na nią jest wstawiane do listy.
W tym miejscu analizator wygeneruje błąd kompilacji, ponieważ pozyskujemy nie-stałe wskazanie na stałą wartość, co może naruszyć chroniony niezmiennik.
Rozwiązaniem byłoby zadeklarowanie listy jako zawierającej wskazania na stałe.
W obecnej formie języka, nie jest to jednak możliwe.

\begin{minipage}{\linewidth}
  
  \begin{lstlisting}[
    numbers=left,
    firstnumber=0,
    caption={Śledzenie wartości, używając atrybutu const},
    aboveskip=0pt,
    label={lst:const_problem_example}
    ]
fn main() -> usize
{
  [const()] let x = 3;
  let list = List<usize*>();
  list.push(&x);
  [const()] let pointer = &x;
}
\end{lstlisting}
\end{minipage}


Właściwość \ref{prop:Reference_adnotations} jest blisko powiązana z właściowścią \ref{prop:Generic_adnotations}.
Rozróżnienie pomiędzy aplikacją adnotacji do wskazania a wskazywanej wartości, jest konieczne aby zapewnić nienaruszenie niezmienników dotyczących wartości.
Listing \ref{lst:const_problem_example} przedstawia ten problem.
Na linii 5, do zmiennej \lstinline{pointer} przypisywany jest adres zmiennej \lstinline{x}.
Pomimo zaaplikowania atrybutu \lstinline{const} do nowej zmiennej, analizator generuje błąd.
Adnotacja została tutaj zaaplikowana do wartości wskazania, nie do wskazywanej wartości.
W C-=-1 istnieją sposoby na obejście tego ograniczenia, jednak lepsze rozwiązanie powinno powstać w wyniku prac opisanych w rozdziale \ref{further:adnotated_type_system}.%todo: example?

Wszystkie te właściwości wskazują na silne powiązanie pomiędzy systemem adnotacji a typów.
Sposób na połączenie tych aspektów C-=-1 powinno zostać bardziej dogłębnie zbadane w przyszłej pracy.
Szczegóły tych badań zostały opisane dokładniej w rozdziale \ref{further:adnotated_type_system}.


W C/C++ modyfikator \lstinline{const} jest integralną częścią systemu typów.
Typ \lstinline{int*} jest różny od \lstinline{int const*} i konwersja między nimi istnieje tylko w jedną stronę.
Wszystkie problemy, wymienione w tym rozdziale nie mają odzwierciedlenia w C/C++, ponieważ ten modyfikator w nich jest częścią systemu typów, a nie rozszerzeniem języka.

\subsection{Generowanie kodu}

Model semantyczny programu, w języku C-=-1, jest mutowalną strukturą danych.
Oznacza to, że kod atrybutów może ją modyfikować w trakcie kompilacji, dodając, usuwając bądź zmieniając kolejność instrukcji i wyrażeń.
Ten aspekt języka, daje programiście szereg nowych możliwości.

\subsubsection{Atrybut Flags}

Jednym z najprostszych przykładów użycia możliwości generowania kodu, jest zadeklarowanie typu enumeracyjnego jako zbiór flag.
Aby to osiągnąć, wszystkie wartości enumeratora muszą być kolejnymi potęgami liczby 2, tak aby binarna alternatywa dowolnych dwóch opcji była unikatowo identyfikowalna.%todo: wording

W większości języków programowania, nie ma możliwości automatycznego przypisywania wartości enumeratora w ten sposób.
W C++ nie istnieje też żaden analizator który wykrywałby błędną definicję takiej flagi.
Przydzielenie wartości oraz weryfikacja czy są one poprawne, jest opdowiedzialnością programisty.

W C\# istnieje atrybut \lstinline{Flags}.
Służy on do walidowania wartości enumeratora i generuje ostrzerzenia w wypadku wykrycia błędu, ale nie przypisuje ich sam.
Programista nadal musi samodzielnie je ustalić.

%todo: cm1

\subsection{Testowanie kodu}

\subsection{Rozszerzalność języka}
\label{Language_extensibility}
Jedną z konsekwencji zaproponowanych mechanizmów jest możliwość rozszerzania języka bez modyfikacji kompilatora.
Oznacza to że pewne elementy składni, obecne w innych językach, stają się zbędnę w C-=-1.
\subsubsection{Symbole zewnętrzne}
Większość języków programowania zawiera mechanizm umożliwiający import symboli zewnętrznych.
Mogą one pochodzić z kodu napisanego w innym języku lub z już skompilowanej biblioteki.

W wypadku C/C++, wymaga to użycia słowa \lstinline{external}, do zdefiniowania symbolu zewnętrznego oraz przekazania odpowiedniego argumentu do linkera.
W C-=-1 ten sam rezultat można osiągnąć, przypisując funkcji odpowiednie metadane, które potem zostaną odczytane przez interfejs backendu.
Wbudowana wersja tego programu obsługuje wczytywanie definicji funkcji z plików lib oraz zastępowanie jej ciała kodem LLVM.

Listing \ref{lst:replaceWithLLVMAttribute} przedstawia atrybut \lstinline{replaceWithLLVMIR} z biblioteki standardowej C-=-1. 
Pobiera on kod LLVMIR z pliku wskazanego przez użytkownika, a następnie ustawia w definicji wybranej funkcji zmienną "llvm-representation".
Backend interface może potem odczytać tą wartość i wykorzystać ją do wygenerowania kodu dla backendu.


\begin{lstlisting}[
    numbers=left,
    firstnumber=0,
    caption={Atrybut zastępujący ciało funkcji kodem LLVM},
    aboveskip=0pt,
    label={lst:replaceWithLLVMAttribute}
]
public att<function> ReplaceWithLLVMIR
{
  private _filename: string;
  private _nameOftypeToReplace: string;
  private _nameToReplace: string;

  public fn construct(
    filename: string,
    nameOfTypeToReplace: string,
    nameToReplace: string)
  {
    self._filename = filename;
    self._nameOftypeToReplace = nameOfTypeToReplace;
    self._nameToReplace = nameToReplace
  }

  public fn attach(f: functionDescriptor)
  {
    let ir = read_all_file(self._filename);
    ir = ir.replace("$" + self._nameOftypeToReplace, self._nameToReplace);
    f.store("llvm-representation", ir);
  }
}

\end{lstlisting}
