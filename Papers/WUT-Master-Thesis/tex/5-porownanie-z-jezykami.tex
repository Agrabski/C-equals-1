\section{Porównanie z innymi językami}
Ponieważ C-=-1 jest językiem badawczym, nie można go porównywać z językami stosowanymi w przemyśle pod względem wygody użycia. Warto jednak przeanalizować, w jaki sposób zaproponowane mechanizmy wpływają na jego użyteczność.
\subsection{Wsparcie dla paradygmatów programowania}
Teoretycznie niemalże w każdym języku da się programować w każdym paradygmacie. Jednak w zależności od struktury tego języka, może być to zadanie prostsze lub trudniejsze. 
\subsubsection{Aspect oriented programming}
Nieoczekiwanym skutkiem zaproponowanych mechanizmów jest wsparcie dla AOP.
\subsubsection{Obiektowe}
C-=-1 został zaprojektowany z myślą o wsparciu stylu obiektowego. Użytkownik może deklarować typy, metody oraz interfejsy. W przeciwieństwie do C++ czy C\#, w C-=-1 nie ma jednak koncepcji dziedziczenia między konkretnymi klasami.

Klasy i interfejsy mogą implementować inne interfejsy. To jest jedyny mechanizm dynamicznego polimorfizmu w C-=-1. Ta decyzja została podjęta częściowo w celu uproszczenia języka, a częściowo ponieważ dziedziczenie między konkretnymi klasami jest uważane za złą praktykę.

\subsection{Walidacja kodu}
Podstawowym celem C-=-1 było zbadanie możliwości statycznej walidacji kodu, używając zaproponowanych mechanizmów metaprogramowania.
W kolejnych rozdziałach omówione zostaną przykładowe analizatory, które zostały zaimplementowane w ramach biblioteki standardowej, bądź których implementacja jest możliwa.
Ma to zademonstrować praktyczne aplikacje udostępnienia programiście modelu semantycznego tworzonego programu.



\subsubsection{Atrybut noDiscard}
\label{no_discard}

Atrybut \lstinline{noDiscard} służy do zapewnienia, że wynik funkcji nie zostanie zgnorowany.
Tego typu adnotacja istnieje w C++ od wersji 17.
Ma on na celu wyeliminować błędy takie jak ignorowanie kodu błędu, czy niepoprawne wywołanie funkcji o mylącej nazwie.

W C-=-1, w przeciwieństwie do większości języków niskiego poziomu, stworzenie analizatora który zapewnia taką walidację jest trywialne.
Listing \ref{lst:noDiscardCm1} zawiera kod atrybutu \lstinline{noDiscard} z biblioteki standardowej C-=-1.
Na linii 4 deklaruje on specjalną funkcję \lstinline{onCall} (specjalne funkcje atrybutów zostały opisane w rozdziale \ref{Attributes_cm1}), która reaguje na wywołania funkcji do której został zaaplikowany.

Wewnątrz tego podprogramu, atrybut sprawdza czy bezpośrednim rodzicem tego wyrażenia jest wyrażenie czy instrukcja.
Jeśli jest nim instrukcja, oznacza to że wynik wywołania jest ignorowany i trzeba zgłosić błąd, używając funkcji \lstinline{raiseError}.
W przeciwnym wypadku żadne akcje nie są konieczne.

Listing \ref{lst:noDiscardUsageCm1} demonstruje zastosowanie atrybut \lstinline{noDiscard}.
Zignorowanie wartości zwracanej przez funkcję oznaczoną tą odnotacją, tak jak na linii 5, powoduje zgłoszenie błędu o kodzie i komunikacie zgodnym z linią 7 listingu \ref{lst:noDiscardCm1}.
Ponadto, kompilator otrzymuje wskazanie do pliku źródłowego na punkt, który wywołał ten błąd.
Ta informacja może być potem użyta do zaprezentowania programiście dokładniejszej diagnostyki, bądź do podkreślenia kodu w zintegrowanym środowisku programistycznym (rozdział \ref{IDE_integration}).

Ten przykład dobrze ilustruje, że mając dostęp do modelu semantycznego programu, implementajca niektórych typów walidacji staje się trywialna.
W większości języków programowania taka analiza wymaga modyfikacji kompilatora albo zewnętrznego narzędzia.

\begin{minipage}{\linewidth}
  
  \begin{lstlisting}[
    numbers=left,
    firstnumber=0,
    caption={Atrybut noDiscard w C-=-1},
    aboveskip=0pt,
    label={lst:noDiscardCm1}
    ]
public att<function> NoDiscard
{
  public fn attach(f: functionDescriptor)
  {}
  public fn onCall(call: functionCallExpression*)
  {
  if(call._parentStatment != null<IInstruction>())
    raiseError(
      &(call._pointerToSource), 
      "Return value of a no-discard function is not used",
      123
    );
  }
}
\end{lstlisting}
\end{minipage}


\begin{minipage}{\linewidth}
  
  \begin{lstlisting}[
    numbers=left,
    firstnumber=0,
    caption={Przykład użycia atrybut noDiscard w C-=-1},
    aboveskip=0pt,
    label={lst:noDiscardUsageCm1}
    ]
[noDiscard()]
fn noDiscardFunction() -> usize;

fn main() -> usize
{
  noDiscardFunction(); // error 123: Return value of
                       // a no-discard function is not use
  let x = noDiscardFunction();     // ok
  let y = x + noDiscardFunction(); // ok
  return noDiscardFunction();      // ok
}
\end{lstlisting}
\end{minipage}

\subsubsection{Atrybut const}
\label{const}

Bardziej złożonym przykładem analizatora, jest atrybut \lstinline{const}.
Odpowiada on modyfiaktorowi \lstinline{const} z języka C++.
Zaaplikowanie go do typu oznacza, że do jego instancja jest niemodyfikowalna.
Każda próba modyfikacji, po zainicjalizowaniu, jest błędem.

W obecnym stanie kompilatora oraz języka, możliwa jest implementacja części tej funkcjonalności.
Pełne wsparcie dla tego modyfikatora, przy użyciu atrybutu, wymaga od C-=-1 następujących właściwości:
\begin{enumerate}
  \item \label{prop:Attribute_function_overloading} Atrybuty są brane pod uwagę w trakcie wyboru przeciążenia funkcji
  \item \label{prop:Generic_adnotations} Istnieje sposób na modyfikowanie zachowania zmiennych, pól i parametrów w generykach, przy tworzeniu ich instancji
  \item \label{prop:Reference_adnotations} Przy aplikowaniu atrybutu do zmiennej typu referencyjnego, istnieje sposób na rozróżnienie między stałym wskazaniem a wskazaniem na stałą.
\end{enumerate}

Właściwość \ref{prop:Attribute_function_overloading} jest już udokumentowaną, choć nieprzetestowaną, częścią języka (rozdział \ref{Attributes_definition}).


\subsection{Generowanie kodu}

\subsubsection{Atrybut Flags}

\subsection{Testowanie kodu}

\subsection{Rozszerzalność języka}
\label{Language_extensibility}
Jedną z konsekwencji zaproponowanych mechanizmów jest możliwość rozszerzania języka bez modyfikacji kompilatora.
Oznacza to że pewne elementy składni, obecne w innych językach, stają się zbędnę w C-=-1.
\subsubsection{Symbole zewnętrzne}
Większość języków programowania zawiera mechanizm umożliwiający import symboli zewnętrznych.
Mogą one pochodzić z kodu napisanego w innym języku lub z już skompilowanej biblioteki.

W wypadku C/C++, wymaga to użycia słowa \lstinline{external}, do zdefiniowania symbolu zewnętrznego oraz przekazania odpowiedniego argumentu do linkera.
W C-=-1 ten sam rezultat można osiągnąć, przypisując funkcji odpowiednie metadane, które potem zostaną odczytane przez interfejs backendu.
Wbudowana wersja tego programu obsługuje wczytywanie definicji funkcji z plików lib oraz zastępowanie jej ciała kodem LLVM.

Listing \ref{lst:replaceWithLLVMAttribute} przedstawia atrybut \lstinline{replaceWithLLVMIR} z biblioteki standardowej C-=-1. 
Pobiera on kod LLVMIR z pliku wskazanego przez użytkownika, a następnie ustawia w definicji wybranej funkcji zmienną "llvm-representation".
Backend interface może potem odczytać tą wartość i wykorzystać ją do wygenerowania kodu dla backendu.


\begin{lstlisting}[
    numbers=left,
    firstnumber=0,
    caption={Atrybut zastępujący ciało funkcji kodem LLVM},
    aboveskip=0pt,
    label={lst:replaceWithLLVMAttribute}
]
public att<function> ReplaceWithLLVMIR
{
  private _filename: string;
  private _nameOftypeToReplace: string;
  private _nameToReplace: string;

  public fn construct(
    filename: string,
    nameOfTypeToReplace: string,
    nameToReplace: string)
  {
    self._filename = filename;
    self._nameOftypeToReplace = nameOfTypeToReplace;
    self._nameToReplace = nameToReplace
  }

  public fn attach(f: functionDescriptor)
  {
    let ir = read_all_file(self._filename);
    ir = ir.replace("$" + self._nameOftypeToReplace, self._nameToReplace);
    f.store("llvm-representation", ir);
  }
}

\end{lstlisting}
