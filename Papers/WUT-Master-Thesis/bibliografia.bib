@book{nielson2004principles,
  title={Principles of Program Analysis},
  author={Nielson, F. and Nielson, H.R. and Hankin, C.},
  isbn={9783540654100},
  lccn={99047677},
  url={https://books.google.pl/books?id=RLjt0xSj8DcC},
  year={2004},
  publisher={Springer Berlin Heidelberg}
}

@book{gang_of_four:design_patterns,
author = {Gamma, Erich and Helm, Richard and Johnson, Ralph and Vlissides, John},
title = {Design Patterns: Elements of Reusable Object-Oriented Software},
year = {1995},
isbn = {0201633612},
publisher = {Addison-Wesley Longman Publishing Co., Inc.},
address = {USA}
}

@inbook{ebnf,
author = {McCracken, Daniel D. and Reilly, Edwin D.},
title = {Backus-Naur Form (BNF)},
year = {2003},
isbn = {0470864125},
publisher = {John Wiley and Sons Ltd.},
address = {GBR},
abstract = {Backus-Naur Form, named after John W. Backus of the US and Peter Naur of Denmark, and usually written BNF, is the best-known example of a meta-language (q.v.), i.e. one that syntactically describes a programming language. Using BNF it is possible to specify which sequences of symbols constitute a syntactically valid program in a given language. (The question of semantics--i.e, what such valid strings of symbols mean--must be specified separately.) A discussion of the basic concepts of BNF follows.},
booktitle = {Encyclopedia of Computer Science},
pages = {129–131},
numpages = {3}
}


@book{puntambekar:compiler_design,
  title={COMPILER DESIGN},
  author={A Puntambekar},
  isbn={9350380870},
  year={2011},
  publisher={Technical Publications}
}

@article{survey_of_metaprograming,
author = {Lilis, Yannis and Savidis, Anthony},
year = {2019},
month = {10},
pages = {1-39},
title = {A Survey of Metaprogramming Languages},
volume = {52},
journal = {ACM Computing Surveys},
doi = {10.1145/3354584}
}
@online{stroustrup_com,
    title="Bjarne Stroustrup Website",
    author = "Bjarne Stroustrup",
    url= "stroustrup.com/bs_faq.html",
    urldate = {2020-10-28},
}

@online{csharp:getType,
    title = "GetType method",
    url = "https://docs.microsoft.com/en-us/dotnet/api/system.object.gettype?view=net-5.0#System_Object_GetType",
    urldate = {2021-11-17}
}

@online{csharp:assemblies,
    title = "Assemblies in .Net",
    url = "https://docs.microsoft.com/en-us/dotnet/standard/assembly/",
    urldate = {2021-11-17}
}

@online{csharp:source_generators,
    title = "Source Generators",
    url = "https://docs.microsoft.com/en-us/dotnet/csharp/roslyn-sdk/source-generators-overview",
    urldate = {2021-11-17}
}

@online{csharp:attributes,
    title = "Attributes",
    url = "https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/attributes/",
    urldate = {2021-11-17}
}

@mastersthesis{csharp:reflection_cost,
  author  = {Darovich, Andrew},
  school  = {Cleveland State University },
  title   = {Productivity at the Cost of Efficiency: An Analysis of Advanced C\# Programming},
  year    = {2009}
}

@inproceedings{cpp:reflection:high_performance,
author = {Devadithya, Tharaka and Chiu, Kenneth and Lu, Wei},
title = {C++ Reflection for High Performance Problem Solving Environments},
year = {2007},
isbn = {1565553136},
publisher = {Society for Computer Simulation International},
address = {San Diego, CA, USA},
abstract = {Problem Solving Environments (PSE) in scientific computing domains require the ability to couple High Performance Computing (HPC) components. A PSE facilitates coupling of tasks or computations in order to aid a scientist in finding a solution to a problem or at least getting closer to a solution. Reflection capabilities are required in order to effectively dynamically couple these components. Reflection facilitates adaptive behavior such as rebinding calls to different functions at run-time, or integrating flexible interpreted languages with compiled languages such as C++ or Fortran. Currently, however, reflection is not available in languages commonly used in high performance computing. While there have been several attempts to incorporate reflection into C++, all of them are either intrusive or are not fully compliant with the C++ standard. In this paper, we present a number of use cases for reflective programming, and show how it can be efficiently and robustly implemented in languages such as C++. Our implementation uses code generation to add metadata, and is fully compliant with the standard C++ specification. We compare the overhead of reflection with languages such as Java, and show that our overhead is acceptable for many scenarios. Our reflection library is open-source, and is available at http://www.extreme.indiana.edu/reflcpp.},
booktitle = {Proceedings of the 2007 Spring Simulation Multiconference - Volume 2},
pages = {435–440},
numpages = {6},
keywords = {problem solving environments, generic programming, scientific computing, high performance computing, C++ reflection},
location = {Norfolk, Virginia},
series = {SpringSim '07}
}

@inproceedings{aop:cpp,
author = {Spinczyk, Olaf and Lohmann, Daniel and Urban, Matthias},
year = {2005},
month = {01},
pages = {33-53},
title = {Advances in AOP with AspectC++.}
}

@article{aop,
author = {Abdul Hameed, Omar and Younus, Ahmed and Hassan Abbas, Rasha},
year = {2019},
month = {12},
pages = {2022-2033},
title = {Aspect oriented programming: Concepts, characteristics and implementation},
volume = {7},
doi = {10.21533/pen.v7i4}
}

@book{van1995python,
  title={Python reference manual},
  author={Van Rossum, Guido and Drake Jr, Fred L},
  year={1995},
  publisher={Centrum voor Wiskunde en Informatica Amsterdam}
}

@online{antlr,
    title = "Antlr",
    author = "Parr Terence",
    url = "https://www.antlr.org/",
    urldate={2021-11-17}
}

@online{cpp:core_guidelines,
    title="C++ Core Guidelines",
    author = "ISOCPP",
    url= "isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines",
    urldate = {2020-10-28},
}

@online{npm,
    title = "NPM",
    author = "npm Inc.",
    url = "https://www.npmjs.com/",
    urldate = {2020-11-17}
}

@online{roslyn,
    title="Roslyn",
    author = "Dotnet",
    url = "github.com/dotnet/roslyn",
    urldate = {2021-11-12}
}

@online{rust,
    author="Rust team",
    title="Rust",
    url="www.rust-lang.org/",
    urldate = {2021-11-12}
}

@article{template_turing_complete,
author = {Veldhuizen, Todd},
year = {2003},
month = {07},
pages = {},
title = {C++ Templates are Turing Complete}
}
@unpublished{gcc_warnings,
    author = "Free Software Foundation",
    note   = "Dostęp zdalny (24.10.2020): \url{https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html}",
}
@techreport{ISO:2012:III,
  added-at = {2012-10-08T01:13:47.000+0200},
  address = {Geneva, Switzerland},
  author = {{ISO}},
  bibdate = {Mon Dec 19 11:12:12 2011},
  bibsource = {http://www.math.utah.edu/pub/tex/bib/isostd.bib},
  biburl = {https://www.bibsonomy.org/bibtex/24b660c16d9a5ab0ad595b1555402c797/gron},
  day = 28,
  interhash = {ff5df6d7fa67f89d7d5ea964dab3e3c9},
  intrahash = {4b660c16d9a5ab0ad595b1555402c797},
  keywords = {C++ Specification Standard},
  month = feb,
  pages = {1338 (est.)},
  publisher = {International Organization for Standardization},
  remark = {Revises ISO/IEC 14882:2003.},
  timestamp = {2012-10-08T01:13:47.000+0200},
  title = {{ISO/IEC 14882:2011 Information technology --- Programming languages --- C++}},
  type = {Standard},
  url = {http://www.iso.org/iso/iso_catalogue/catalogue_tc/catalogue_detail.htm?csnumber=50372},
  year = 2012
}

@article{cpp:function_overload_frontend,
  title={Research on the Design of Function Overload Resolution by C++ Compiler Front End [J]},
  author={Kang, He and Chao, Chen and Jian, Liu},
  journal={Electronic Science and Technology},
  volume={2},
  year={2009}
}
  @MastersThesis{Lattner:MSThesis02,
    author  = {Chris Lattner},
    title   = "{LLVM: An Infrastructure for Multi-Stage Optimization}",
    school  = "{Computer Science Dept., University of Illinois at Urbana-Champaign}",
    year    = {2002},
    address = {Urbana, IL},
    month   = {Dec}
  }
  @article{10.1145/2103621.2103709,
author = {Zhao, Jianzhou and Nagarakatte, Santosh and Martin, Milo M.K. and Zdancewic, Steve},
title = {Formalizing the LLVM Intermediate Representation for Verified Program Transformations},
year = {2012},
issue_date = {January 2012},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {47},
number = {1},
issn = {0362-1340},
url = {https://doi.org/10.1145/2103621.2103709},
doi = {10.1145/2103621.2103709},
abstract = {This paper presents Vellvm (verified LLVM), a framework for reasoning about programs expressed in LLVM's intermediate representation and transformations that operate on it. Vellvm provides a mechanized formal semantics of LLVM's intermediate representation, its type system, and properties of its SSA form. The framework is built using the Coq interactive theorem prover. It includes multiple operational semantics and proves relations among them to facilitate different reasoning styles and proof techniques.To validate Vellvm's design, we extract an interpreter from the Coq formal semantics that can execute programs from LLVM test suite and thus be compared against LLVM reference implementations. To demonstrate Vellvm's practicality, we formalize and verify a previously proposed transformation that hardens C programs against spatial memory safety violations. Vellvm's tools allow us to extract a new, verified implementation of the transformation pass that plugs into the real LLVM infrastructure; its performance is competitive with the non-verified, ad-hoc original.},
journal = {SIGPLAN Not.},
month = {jan},
pages = {427–440},
numpages = {14},
keywords = {memory safety, Coq, LLVM}
}

@inproceedings{llvmir,
author = {Zhao, Jianzhou and Nagarakatte, Santosh and Martin, Milo M.K. and Zdancewic, Steve},
title = {Formalizing the LLVM Intermediate Representation for Verified Program Transformations},
year = {2012},
isbn = {9781450310833},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2103656.2103709},
doi = {10.1145/2103656.2103709},
abstract = {This paper presents Vellvm (verified LLVM), a framework for reasoning about programs expressed in LLVM's intermediate representation and transformations that operate on it. Vellvm provides a mechanized formal semantics of LLVM's intermediate representation, its type system, and properties of its SSA form. The framework is built using the Coq interactive theorem prover. It includes multiple operational semantics and proves relations among them to facilitate different reasoning styles and proof techniques.To validate Vellvm's design, we extract an interpreter from the Coq formal semantics that can execute programs from LLVM test suite and thus be compared against LLVM reference implementations. To demonstrate Vellvm's practicality, we formalize and verify a previously proposed transformation that hardens C programs against spatial memory safety violations. Vellvm's tools allow us to extract a new, verified implementation of the transformation pass that plugs into the real LLVM infrastructure; its performance is competitive with the non-verified, ad-hoc original.},
booktitle = {Proceedings of the 39th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {427–440},
numpages = {14},
keywords = {Coq, LLVM, memory safety},
location = {Philadelphia, PA, USA},
series = {POPL '12}
}


@techreport{ISO:cpp20,
type = {Standard},
key = {ISO/IEC 14882:2020(E) },
month = mar,
year = {2020},
title = {{Programming languages — C++}},
volume = {2020},
address = {Geneva, CH},
institution = {International Organization for Standardization}
}

@techreport{ISO:cpp17,
type = {Standard},
key = {ISO/IEC 14882:2017 },
month = mar,
year = {2017},
title = {{Programming languages — C++}},
volume = {2017},
address = {Geneva, CH},
institution = {International Organization for Standardization}
}

@techreport{ecma:cli,
type = {Standard},
key = {ECMA-335},
month = jun,
year = {2012},
title = {Common Language Infrastructure (CLI)},
volume = {2020},
institution = {ECMA (European Association for Standardizing Information and Communication Systems), pub-ECMA: adr,},
}

% Fragment książki (np. zakres stron).
@inbook{wang97,
    author      = "Hao Wang",
    title       = "A Logical Journey: From G{\"o}del to Philosophy.",
    publisher   = "A Bradford Book",
    pages       = "316",
    year        = "1997"
}

% Fragment książki (np. esej), posiadający własny tytuł.
@incollection{goedel95,
    author      = "Kurt G{\"o}del",
    title       = "Texts relating to the ontological proof",
    booktitle   = "Unpublished Essays and Lectures",
    publisher   = "Oxford University Press",
    pages       = "429--437",
    year        = "1995",
}

% Publikacja konferencyjna.
@inproceedings{benzmuller2014,
    author       = "{Ch}. Benzmuller and B. W. Paleo",
    title        = "Automating {G\"o}del’s {O}ntological {P}roof of {G}od’s {E}xistence with {H}igher-order {A}utomated {T}heorem {P}rovers",
    booktitle    = "European	Conference on Artificial Intelligence",
    publisher    = "IOS Press",
    howpublished = "Dostęp zdalny (10.04.2019): \url{http://page.mi.fu-berlin.de/cbenzmueller/papers/C40.pdf}",
    year         = "2014",
}

% Raport techniczny.
@techreport{duqu2011,
    author      = "Bencsáth, B. and Pék, G. and Buttyán, L. and Félegyházi M.",
    title       = "{D}uqu: {A} {S}tuxnet-like malware found in the wild",
    institution = "Laboratory of Cryptography and System Security, Hungary",
    year        = "2011"
}

% Specyfikacja techniczna.
@manual{shs2015,
    title        = "{FIPS} 180-4: {S}ecure {H}ash {S}tandard ({SHS})",
    howpublished = "Dostęp zdalny (13.03.2019): \url{https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf}",
    year         = "2015"
}

% Praca magisterska.
@mastersthesis{wozniak2018,
    author = "Woźniak, Piotr",
    title  = "{P}rogramowanie kwadratowe w usuwaniu efektu rozmycia ruchu w fotografii cyfrowej",
    school  = "Wydział Elektroniki i Technik Informacyjnych, Politechnika Warszawska",
    year   = "2018",
}

% Nieopublikowany artykuł, dostępny np. tylko w internecie.
@unpublished{koons2005,
    author = "Koons, Robert C.",
    title  = "{S}obel on {G\"o}del’s {O}ntological {P}roof",
    note   = "Dostęp zdalny (25.04.2019): \url{http://www.robkoons.net/media/69b0dd04a9d2fc6dffff80b4ffffd524.pdf}",
    year   = "2005"
}

% Źródło innego typu, np. repozytorium na GitHubie.
@misc{dcp19,
    author       = "Brodzki, Artur M.",
    title        = "{I}mplementation of own steganography protocol {DCP}-19, loosely based on {HICCUPS}",
    howpublished = "Dostęp zdalny (14.03.2019): \url{https://github.com/ArturB/DCP-19}",
    year         = "2019"
}
@inproceedings{Klimiankou:contexpr_great_good_wrong_idea,
author = {Klimiankou, Yauhen},
year = {2019},
month = {12},
pages = {3-8},
title = {Constexpr: A Great Good but Wrong Idea},
doi = {10.1109/ISPRAS47671.2019.00007}
}
@inproceedings{McLoughlin1989ImperativeEF,
  title={Imperative Effects from a Pure Functional Language},
  author={L. McLoughlin and E. S. Hayes},
  booktitle={Functional Programming},
  year={1989}
}

 @misc{wagner_2021, title={Nullable reference types}, url={https://docs.microsoft.com/en-us/dotnet/csharp/nullable-references}, journal={Microsoft Docs}, publisher={Microsoft}, author={Wagner, Bill}, year={2021}, month={Sep}} 

@book{cppTemplatesCompleteGuide,
author = {Vandevoorde, David and Josuttis, Nicolai M. and Gregor, Douglas},
title = {C++ Templates: The Complete Guide (2nd Edition)},
year = {2017},
isbn = {0321714121},
publisher = {Addison-Wesley Professional},
edition = {2nd},
abstract = {Templates are among the most powerful features of C++, but they remain misunderstood
and underutilized, even as the C++ language and development community have advanced.
In C++ Templates, Second Edition, three pioneering C++ experts show why, when, and
how to use modern templates to build software thats cleaner, faster, more efficient,
and easier to maintain. Now extensively updated for the C++11, C++14, and C++17 standards,
this new edition presents state-of-the-art techniques for a wider spectrum of applications.
The authors provide authoritative explanations of all new language features that either
improve templates or interact with them, including variadic templates, generic lambdas,
class template argument deduction, compile-time if, forwarding references, and user-defined
literals. They also deeply delve into fundamental language concepts (like value categories)
and fully cover all standard type traits. The book starts with an insightful tutorial
on basic concepts and relevant language features. The remainder of the book serves
as a comprehensive reference, focusing first on language details and then on coding
techniques, advanced applications, and sophisticated idioms. Throughout, examples
clearly illustrate abstract concepts and demonstrate best practices for exploiting
all that C++ templates can do. Understand exactly how templates behave, and avoid
common pitfalls Use templates to write more efficient, flexible, and maintainable
software Master todays most effective idioms and techniques Reuse source code without
compromising performance or safety Benefit from utilities for generic programming
in the C++ Standard Library Preview the upcoming concepts feature The companion website,
tmplbook.com, contains sample code and additional updates.}
}

@book{intro_to_compiler_design,
author = {Mogensen, Torben \AE{}gidius},
title = {Introduction to Compiler Design},
year = {2011},
isbn = {0857298283},
publisher = {Springer Publishing Company, Incorporated},
edition = {1st},
abstract = {This textbook is intended for an introductory course on Compiler Design, suitable
for use in an undergraduate programme in computer science or related fields.Introduction
to Compiler Design presents techniques for making realistic, though non-optimizing
compilers for simple programming languages using methods that are close to those used
in "real" compilers, albeit slightly simplified in places for presentation purposes.
All phases required for translating a high-level language to machine language is covered,
including lexing, parsing, intermediate-code generation, machine-code generation and
register allocation. Interpretation is covered briefly.Aiming to be neutral with respect
to implementation languages, algorithms are presented in pseudo-code rather than in
any specific programming language, and suggestions for implementation in several different
language flavors are in many cases given. The techniques are illustrated with examples
and exercises.The author has taught Compiler Design at the University of Copenhagen
for over a decade, and the book is based on material used in the undergraduate Compiler
Design course there.Additional material for use with this book, including solutions
toselected exercises, is available at http://www.diku.dk/~torbenm/ICD}
}

@bathesis {grabski2020,
    author = "Grabski, Adam",
    title  = "Rose Parser Generator",
    school  = "Wydział Elektroniki i Technik Informacyjnych, Politechnika Warszawska",
    year   = "2020",
}
