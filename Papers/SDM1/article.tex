\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage[T1]{fontenc}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\begin{document}

\title{Kompilacja przez interpretację: metaprogramowanie w C-=-1
}

\author{\IEEEauthorblockN{1\textsuperscript{st} Adam Grabski}
    \IEEEauthorblockA{\textit{Wydział Elektroniki i Technik Informatycznych} \\
        \textit{Politechnika Warszawska}\\
        Warszawa, Polska \\
        adam.grabski.stud@pw.edu.pl}
}

\maketitle

\begin{abstract}
    Statyczne metaprogramowanie to technika programistyczna umożliwiająca analizę, modyfikację lub generację kodu w czasie kompilacji.
    Współczesne, niskopoziomowe języki programowania wprowadzają wsparcie dla tych mechanizmów, w ograniczonym zakresie.
    W ramach tej pracy zaproponowano nowy język programowania: C-=-1, zaprojektowany od początku z myślą o metaprogramowaniu, oraz nowe podejście do konstrukcji kompilatora: kompilacja przez interpretację.
\end{abstract}

\begin{IEEEkeywords}
    Metaprogramowanie, język programowania, kompilator, kompilacja
\end{IEEEkeywords}

\section{Wstęp}
Dwa trendy w rozwoju współczesnych języków programowania niskiego poziomu to wykonanie kodu w czasie kompilacja oraz wsparcie dla statycznego metaprogramowania.
Mechanizmy takie jak system makr w Rust oraz szablony w C++ umożliwiają generowanie kodu oraz jego analizę w pewnym ograniczonym zakresie.
Dają one niewielki wgląd w strukturę programu oraz wykorzystują składnię odrębną od reszty języka, co utrudnia ich efektywne wykorzystanie.

Te języki, umożliwiają też wykonywanie kodu w czasie kompilacji, jednak tutaj programista także spotyka się ze znacznymi ograniczeniami.
C++ wprowadził tę możliwość jako pierwszy, tworząc funkcje constexpr w C++11.
Na początku dawały dostęp wyłącznie do najbardziej podstawowych elementów języka, jendak z czasem te ograniczenia były znoszone.
W C++20, funkcje constepxr mają już tylko jedno, poważne ograniczenie: nie mogą zwracać dynamicznie alokowanej pamięci.
Rust podąża śladami C++, wprowadzając funkcje const.

Celem C-=-1 jest umożliwienie wykonywania oraz dowolnego modyfikowania kodu w czasie kompilacji.
Osiągnięto to poprzez stworzenie interpretera tego języka, a następnie udostępnienie mu programu jako modyfikowalnej struktury danych.
W ten sposób, dowolny fragment kodu może być wykonany w czasie kompilacji oraz użytkownik może dowolnie modyfikować swój program, używając normalnej składni.

\section{Struktura języka}

Język C-=-1 bazuje na C++, z elementami składni Rust.
Program może składać się z przestrzeni nazw, funkcji oraz typów takich jak klasy, typy enumeracyjne, atrybuty oraz interfejsy.
Tak jak C++, C-=-1 jest językiem programowania ogólnego przeznaczenia, ze wsparciem dla programowania obiektowego.

\subsection{System typów}

W przeciwieństwie do C++, C-=-1 nie pozwala na dziedziczenie po klasach.
Zamiast tego, wprowadza koncepcję interfejsu z języków takich jak C\#.
Interfejs może zawierać wyłącznie nagłówki metod, które implementująca klasa musi zdefiniować.
Klasy i interfejsy mogą dziedziczyć po dowolnej ilości interfejsów.

Klasyczne dziedziczenie zostało usunięte aby uprościć model języka.
Możliwość definiowania metod oraz pól na każdym poziomie hierarchi dziedziczenia powodowałoby nieoczywiste zachowanie przy pobieraniu listy członków klasy.
Na przykład, nie jest jasnym czy metoda zwracająca listę pól klasy, powinna uwzględniać pola z klasy bazowej.
W ostatecznie wybranym modelu języka wszystkie pola i metody muszą być zdefiniowane w typie konkretnym, natomiast wcześniej wspomniany problem jest ograniczony do iterowania po metodach interfejsów.

Atrybuty w języku C-=-1 są bardzo podobne do tych które  można znaleźć w języku C\#.
Można nimi adnotować deklaracje typów, zmiennych oraz funkcji.
Deklarując atrybut, użytkownik może zaimplementować szereg specjalnych metod, reagujących na użycie adnotowanego elementu.
Na przykład dla atrybutu dołączanego do funkcji, użytkownik może napisać metodę, która będzie wykonywana za każdym razem, kiedy dana funkcja jest wywoływana w kodzie.
Wewnątrz tej metody, można wykonywać dowolne transformacje na reprezentacji pośredniej.

\section{Proces kompilacji}

Projekt procesu kompilacji jest najważniejszą częścią tej pracy.
W porównaniu z typowym kompilatorem, w którym wykonywanie kodu jest tylko niewielkim fragmentem całego procesu kompilacji, w C-=-1 interpreter jest głównym modułem kompilatora.
Najogólniej, proces kompilacji programu składa się z następujących kroków:
\begin{enumerate}
    \item Budowa reprezentacji pośredniej.
    \item Wykonanie operacji metaprogramistycznych w kodzie.
    \item Wykonanie metod atrybutów.
    \item Wykonanie kodu w interfejsie backendu.
\end{enumerate}

Reprezentacja pośrednia kodu użytkownika, jest budowana używając struktur danych interpretera.
Utrudnia to znacząco pisanie kompilatora, ponieważ efektywnie usuwa z języka statyczne typowanie.
Ta decyzja została podjęta, aby uniknąć konieczności konwersji pomiędzy reprezentacją pośrednią widzianą przez kompilator i kod użytkownika oraz synchronizowania tych dwóch struktur danych.


\subsection{Interpreter}
\subsection{Kompilator}
\section{Zalety nowego podejścia}

Postawienie możliwości wykonania kompilowanego kodu jako pierwszy priorytet ma szereg zalet w porównaniu z typowym podejściem.

\subsubsection{Ewaluacja kodu w czasie kompilacji}

W kompilatorach C++ ewaluacja funkcji w trakcie kompilacji powstaje zwykle na bazie systemów, które miały zapewniać proste optymalizacje takie jak wykonywanie operacji arytmetycznych na stałych.
Pomimo tego, że te systemy są obecnie bardzo zaawansowane i potrafią ewaluować niemalże dowolny kod, programiści nie mogą ich używać jawnie.

Jest to spowodowane historią języka C++.
Ewaluacja funkcji w czasie kompilacji została wprowadzona do języka w standardzie C++11.
Oznacza to, że wykonywanie kodu w czasie kompilacji jest dość nowym pomysłem i nie każdy kompilator ma infrastrukturę, która może je wspierać.

W zaproponowanej architekturze, podstawowym komponentem kompilatora jest interpreter.
Oznacza to, że nie istnieje wyrażenie, które nie może być ewaluowane w czasie kompilacji, pod warunkiem, że znane są wszystkie jego argumenty.
W obecnej implementacji niemożliwym jest odczytywanie danych z konsoli oraz wywoływanie funkcji zdefiniowanych jako symbol zewnętrzny.

\subsubsection{Rozszerzalność języka}

\subsubsection{Implementacja pierwszego kompilatora}

Nieoczekiwaną zaletą opisywanego podejścia jest ułatwienie implementacji pierwszego kompilatora.
W wielu językach programowania kompilator jest napisany w języku, który kompiluje.
Takie podejście ma wiele zalet, takich jak przyśpieszanie rozwoju języka.
W wielu wypadkach, na początku istnienia kompilator jest jedynym dużym projektem napisanym w danym języku.
Takie kompilatory są określane jako Bootstrapping Compiler \cite{b1}.




\section{Możliwa krytyka}

Użycie metaprogramowania zwiększa złożoność kodu.
Wymaga dobrego zrozumienia modelu języka oraz rozumowania na wyższym poziomie abstrakcji.
Ta wada jest szczególnie widoczna w zaproponowanym języku.

Kod napisany przez użytkownika może być w trakcie kompilacji modyfikowany nadpisywany bądź nawet usuwany.
Użycie C-=-1 jest więc dużo bardziej wymagające niż typowego języka programowania.
Można jednak argumentować, że zwiększenie mocy języka dzięki zaproponowanym mechanizmom zmniejszy ilość miejsc, w których mogą się pojawić błędy na tyle, aby przeważyć koszt związany ze zwiększoną złożonością programu.

Innym możliwym źródłem krytyki są struktury danych zastosowane przy implementacji kompilatora.
Ponieważ z perspektywy kodu kompilatora, wszystkie elementy modelu semantycznego mają ten sam typ, a dostęp do pól odbywa się przez ich nazwę, kod kompilatora może zawierać błędy występujące zwykle wyłącznie w językach skryptowych.
Rozwój tego programu musi być więc wykonywany bardzo ostrożnie.
Parametry funkcji muszą być ręcznie walidowane na każdym kroku.
To podejście zwiększa prawdopodobieństwo wystąpienia błędu w kompilatorze, utrudnia refaktoryzację i wymusza pisanie większej ilości testów niż normalnie.

Ta decyzja została podjęta, ponieważ alternatywą było dokonywanie konwersji pomiędzy modelem semantycznym, na którym operuje kompilator i tym na którym operuje kod użytkownika.
Takie rozwiązanie zapewniłoby silne typowanie w projekcie, ale wymusiłoby utrzymywanie dwóch struktur danych o tej samej zawartości, niezależnie od siebie.
Ostatecznie doprowadziłoby to do większej ilości błędów, niż miałoby zapobiec.



\section{Podsumowanie}

\begin{thebibliography}{00}
    \bibitem{b1} J Reynolds ``Bootstrapping a self-compiling compiler from machine X to machine Y'' Journal of Computing Sciences in Colleges - JCSC, sty 2003.
\end{thebibliography}
\vspace{12pt}
\color{red}
IEEE conference templates contain guidance text for composing and formatting conference papers. Please ensure that all template text is removed from your conference paper prior to submission to the conference. Failure to remove the template text from your paper may result in your paper not being published.

\end{document}
