As static metaprogramming is becoming more relevant, compilers must adapt to acomodate them.
This requires exposing more information about the code, from the compiler, to the programmer as well as more powerfull compile-time function execution capabilities.
The interpreter component of a compiler therefore becomes more and more prominent.

CTFE first approach places the interpreter as the central component of the compiler.
Translation of user code into the executable form is done using an interpreted module, written in the target language, and uses the same data structures accessible to the programmer.
This boosts the flexibility and extensibility of the compiler and ensures the completness of the available metadata and the ability to execute any code at compile-time.

CTFE first pattern is design with compiling low-level, non-garbage-collected, reflection-enabled languages in mind.
It was created in order to compile C-=-1, which aimed to allow the programmer to execute any code at compile time, as well as anylyze and modify the program structure.
Thanks to the extensibility of the designed compiler, programs written in C-=-1 can also generate marshalling bindings for other languages and support a variety of unexpected programming paradigms.

The flexibility and extensibility of CTFE frist are offset by higher complexity of the compiler and rigidity of the data strctures used.
The interpreted module, which is a large component, is difficult to debug due to the additional indirection.
Since the programmer has access to the same data structures, used by the compiler, they are a part of the compiled languages standard library and backwards compability must be maitained.
