\section{Related work}
\label{related-work}

Many currently used programming languages allow the programmer to execute some code at compile time, for example: C\# \cite{csharp:source_generators,roslyn}, Rust \cite{rust, klabnik2019rust} and C++ \cite{ISO:cpp20}.

Rust language compiler is the most similar in capability, to what was demonstrated with C-=-1, as a feature of CTFEF.
It allows the user to write code that performs some transformations of the program, and interact with the environment during the build process.
The two relevant features are build scripts and macros.
Rust macros, similar to the classic C-style preprocessor macros, generate additional code as text.
The major difference between the systems is that Rust macros operate on tokens, rather than text, and use syntax similar to regular Rust code.
This mechanism is powerful, allowing the user to rewrite code to avoid repetition, simplify certain tasks and create new syntax.
They are however unable to reflect on the program or obtain some information available to the compiler.

Build scripts, on the other hand, are programs that execute before the compilation of the main package.
They prepare the environment for building the program, for example, compile external dependencies.
The structure of the program being compiled, is not available for build scripts.
Build scripts accessing such data, would have to analyze the code by themselves, without any compiler assistance, and that makes automatic generation of bindings for other programming languages very difficult.

C\# compiler, called Roslyn \cite{roslyn}, has the closest set of capabilities to what CTFEF aims to achieve.
Its architecture allows for user-defined analyzers and code generators using a program model generated by the compiler \cite{vermeir2022net}.
These compiler extensions can be used and distributed as regular code packages, for example using nuget package manager \cite{balliauw2013nuget}.
C\# code analyzers have access to entire analyzed code-base and to semantic analysis functionality of the compiler.
Using CTFEF for the purposes of code analysis would not offer any additional benefits.

C\# code generators are more limited.
They can only add new files, not modify the existing ones.
All code generators operate on a read-only snapshot of the code base.
This also means that if more than one generator operates during compilation, they are unaware of the files created by other generators\cite{slimaksource}.
This limitation was introduced for a number of reasons.
If source generators could influence each other, the order in which they run would become important and could lead to unpredictable behavior.
Compilation performance would also be affected, as parallelization of source generators would become more difficult or even impossible.

Although CTFEF was inspired by the C\# compiler, there are significant differences between them.
C\# compiler extensions are separate, compiled, dynamic libraries loaded by the compiler and executed as a regular code.
In CTFEF components that analyze and generate code are part of regular code base and are not compiled separately.
The intermediate representation of these modules is interpreted at compile time, together with other parts of compiler, and operate on the same representation of user program.
CTFEF is further described in chapter \ref{compiler-design}.

