import {functionDescriptor packageDescriptor typeDescriptor} from {cm1mLang::compiler}
import {llvmFunction llvmModule llvmType compilationResult llvmValue} from {cm1mLang::compiler::backend}
import {enumerate print dictionary} from {std}
import {ReplaceWithLLVMIR} from {std::compiler}
import {variableDescriptor} from {cm1mLang::compiler::ir}
import {string null dictionary bool} from {cm1mLang}

private fn getFunction(f: functionDescriptor, registry: packageRegistry*) -> llvmFunction
{
	if(registry._functions.hasKey(f))
		return *registry._functions.get(f);
	print(f.qualifiedName());

	let attribute = f.get_attribute<_att_ ReplaceWithLLVMIR>();

	if(attribute != null<_att_ ReplaceWithLLVMIR>())
		return createFunctionFromLLVMIR(f, registry._compilationResult, attribute);
	else
	{
		if(f.isIntrinsic())
		{
			if(f.qualifiedName() == "::string::length")
			{
				let r = getStringLength(f, registry);
				registry._functions.push(f, r);
				return r;
			}
			if(f.name() == "length") //todo: this is about arrays
			{
				let r = getArrayLength(f, registry);
				registry._functions.push(f, r);
				return r;
			}
			if(f.qualifiedName() == "::true")
			{
				let r = getTrue(f, registry);
				registry._functions.push(f, r);
				return r;
			}
			if(f.qualifiedName() == "::false")
			{
				let r = getFalse(f, registry);
				registry._functions.push(f, r);
				return r;
			}
			if(f.qualifiedName() == "::operator_==")
			{
				let r = getSimpleComparisonOperator(f, registry);
				registry._functions.push(f, r);
				return r;
			}
			if(f.qualifiedName() == "::operator_!=")
			{
				let r = getSimpleNotEqualsOperator(f, registry);
				registry._functions.push(f, r);
				return r;
			}
			if(f.qualifiedName() == "::operator_>")
			{
				let r = getSimpleGreaterOperator(f, registry);
				registry._functions.push(f, r);
				return r;
			}
			if(f.qualifiedName() == "::operator_<")
			{
				let r = getSimpleLessOperator(f, registry);
				registry._functions.push(f, r);
				return r;
			}
			if(f.qualifiedName() == "::operator_*")
			{
				let r = getIntegerMultiplication(f, registry);
				registry._functions.push(f, r);
				return r;
			}
			if(f.qualifiedName() == "::operator_+")
			{
				let r = getIntegerAddition(f, registry);
				registry._functions.push(f, r);
				return r;
			}
			if(f.qualifiedName() == "::operator_-")
			{
				let r = getIntegerDifference(f, registry);
				registry._functions.push(f, r);
				return r;
			}
			if(f.qualifiedName() == "::operator_/")
			{
				let r = getIntegerDivision(f, registry);
				registry._functions.push(f, r);
				return r;
			}
		}
		if(f.isBasedOnGeneric())
		{
			if(f.genericInstantiationInfo().generic() == genericFunctionof(null))
				return getNull(f, registry);
		}
		let mod = registry.getModuleFor(f);
		let func = mod.appendFunction(
			f.name(),
			getParameterTypes(f, registry),
			getParameterNames(f, registry),
			getType(f.returnType(), registry)
			);
		registry._functions.push(f, func);
		buildFunction(f, func, registry, mod);
		
		return func;
	}
}

private fn createFunctionFromLLVMIR(f: functionDescriptor, cr: compilationResult, attribute: _att_ ReplaceWithLLVMIR*) -> llvmFunction
{
	let mod = cr.loadModuleFromString(attribute.overridenLLVMIR);
	return mod.functions()[0];
}

private fn buildFunction(f: functionDescriptor, llvmF: llvmFunction, registry: packageRegistry*, mod: llvmModule)
{
	let variables = dictionary<variableDescriptor, llvmValue>();
	let params = f.parameters();
	for(i in enumerate(0, params.length()))
		variables.push(params[i], llvmF.getParameter(i));
	let builder = llvmF.getBuilder();
	let code = f.code();
	for(i in enumerate(0, code.length()))
		build_instruction(code[i], &builder, &variables, registry);
}

private fn getParameterTypes(f: functionDescriptor, registry: packageRegistry*) -> llvmType[]
{
	let result = <llvmType>[];
	let parameters = f.parameters();
	for(i in enumerate(0, parameters.length()))
		result.push(getType(parameters[i].type(), registry));
	return result;
}

private fn getParameterNames(f: functionDescriptor, registry: packageRegistry*) -> string[]
{
	let result = <string>[];
	let parameters = f.parameters();
	for(i in enumerate(0, parameters.length()))
	{
		result.push(parameters[i].name());
	}
	return result;
}

