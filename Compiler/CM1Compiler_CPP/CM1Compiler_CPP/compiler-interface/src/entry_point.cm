import {compilerEntryPoint functionDescriptor packageDescriptor typeDescriptor} from {cm1mLang::compiler}
import {string null usize} from {cm1mLang}
import {compilationResult llvmType llvmInt32Type llvmModule} from {cm1mLang::compiler::backend}
import {enumerate print} from {std}

[compilerEntryPoint()]
public fn entryPoint(packages: packageDescriptor[], result: compilationResult) {
	let registry = packageRegistry(result);
	for(i in enumerate(0, packages.length()))
		compilePackage(packages[i], &registry);
	for(i in enumerate(0, packages.length()))
		completePackage(packages[i], &registry);
}

private fn compilePackage(package: packageDescriptor, registry: packageRegistry*)
{
	let types = package.getAllTypes();
	for(i in enumerate(0, types.length()))
		createType(types[i], package, registry);
}

private fn completePackage(package: packageDescriptor, registry: packageRegistry*) 
{
	let types = package.getAllTypes();
	for(i in enumerate(0, types.length()))
		completeType(types[i], package, registry);
}

private fn createType(t: typeDescriptor, package: packageDescriptor, registry: packageRegistry*)
{
	let lt = registry.getLLVMTypeFor(t, package);
}

private fn completeType(t: typeDescriptor, package: packageDescriptor, registry: packageRegistry*)
{
	if(t != typeof(usize))
	{
		let fields = t.fields();
		let lt = registry.getLLVMTypeFor(t, package);
		let types = <llvmType>[];
		for(i in enumerate(0, fields.length()))
		{
			let field = fields[i];
			types.push(registry.getLLVMTypeFor(field.type(), package));
		}
		lt.setFields(types);
		let cons = t.constructors();
		for(i in enumerate(0, cons.length()))
		{
			let mod = registry.getModuleFor(cons[i]);
			buildConstructor(t, cons[i], package, registry, mod);
		}
	}
}

private fn getParameterTypes(f: functionDescriptor, registry: packageRegistry*) -> llvmType[]
{
	let result = <llvmType>[];
	let parameters = f.parameters();
	for(i in enumerate(0, parameters.length()))
		result.push(registry.getLLVMTypeForExisting(parameters[i].type()));
	return result;
}

private fn getParameterNames(f: functionDescriptor, registry: packageRegistry*) -> string[]
{
	let result = <string>[];
	let parameters = f.parameters();
	print(parameters.length());
	for(i in enumerate(0, parameters.length()))
	{
		result.push(parameters[i].name());
	}
	return result;
}

private fn buildConstructor(t: typeDescriptor, f: functionDescriptor, package: packageDescriptor, registry: packageRegistry*, mod: llvmModule)
{
	let lt = registry.getLLVMTypeFor(t, package);
	let func = mod.appendFunction("construct",getParameterTypes(f, registry), getParameterNames(f, registry), lt);
	let builder = func.getBuilder();
	let value = builder.appendAlloca(lt, "self");
	builder.appendRet(value);
}