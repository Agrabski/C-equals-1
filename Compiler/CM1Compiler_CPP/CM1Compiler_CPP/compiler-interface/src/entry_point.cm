import {compilerEntryPoint packageDescriptor typeDescriptor functionDescriptor} from {cm1mLang::compiler}
import {usize string} from {cm1mLang}
import {compilationResult llvmType llvmFunction} from {cm1mLang::compiler::backend}
import {enumerate print dictionary} from {std}

[compilerEntryPoint()]
public fn entryPoint(packages: packageDescriptor[], result: compilationResult) {
	let registry = packageRegistry(result);
	for(i in enumerate(0, packages.length()))
	{
		print(packages[i].name());
		compilePackage(packages[i], &registry, result);
	}
	for(i in enumerate(0, packages.length()))
		completePackage(packages[i], &registry, result);
}

private fn compilePackage(package: packageDescriptor, registry: packageRegistry*, cr: compilationResult)
{
	let types = package.getAllTypes();
	for(i in enumerate(0, types.length()))
		createType(types[i], package, registry);
	
}

private fn completePackage(package: packageDescriptor, registry: packageRegistry*, cr: compilationResult) 
{
	let functionMap = dictionary<functionDescriptor, llvmFunction>();
	let types = package.getAllTypes();
	for(i in enumerate(0, types.length()))
		completeType(types[i], package, registry, cr);
	let functions = package.getAllFunctions();
	for(i in enumerate(0, functions.length()))
		if(functions[i].runtimeExecutable())
		{
			if(functions[i].isAbstract())
				return;
			let x = createFunction(functions[i], package, registry, registry.getModuleFor(functions[i]), cr);
			functionMap.push(functions[i], x);
		}
	for(i in enumerate(0, functions.length()))
		if(functions[i].runtimeExecutable())
		{
			if(functions[i].isAbstract())
				return;
			buildFunction(functions[i], *functionMap.get(functions[i]), package, registry, registry.getModuleFor(functions[i]));
		}

}

private fn createType(t: typeDescriptor, package: packageDescriptor, registry: packageRegistry*)
{
	if(t.excludedAtRuntime())
		return;
	let lt = registry.getLLVMTypeFor(t, package);
}

private fn completeType(t: typeDescriptor, package: packageDescriptor, registry: packageRegistry*, cr: compilationResult)
{
	if(t.excludedAtRuntime())
		return;
	if(t.isBasedOnGeneric())
	{
		let instantiationData = t.genericInstantiationInfo();
		if(instantiationData.generic() == genericTypeof(array))
			return;
	}
	if(t != typeof(usize) && (t != typeof(string)) && (t.referenceCount() == 0))
	{
		let fields = t.fields();
		let lt = registry.getLLVMTypeFor(t, package);
		let types = <llvmType>[];
		for(i in enumerate(0, fields.length()))
		{
			let field = fields[i];
			types.push(registry.getLLVMTypeFor(field.type(), package));
		}
		lt.setFields(types);
		let cons = t.methods();
		for(i in enumerate(0, cons.length()))
			if(cons[i].runtimeExecutable())
			{
				if(cons[i].isAbstract())
					return;
				let mod = registry.getModuleFor(cons[i]);
				createFunction(cons[i], package, registry, mod, cr);
			}
	}
}
