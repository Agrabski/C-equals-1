import {compilerEntryPoint packageDescriptor typeDescriptor} from {cm1mLang::compiler}
import {usize} from {cm1mLang}
import {compilationResult llvmType} from {cm1mLang::compiler::backend}
import {enumerate} from {std}

[compilerEntryPoint()]
public fn entryPoint(packages: packageDescriptor[], result: compilationResult) {
	let registry = packageRegistry(result);
	for(i in enumerate(0, packages.length()))
		compilePackage(packages[i], &registry);
	for(i in enumerate(0, packages.length()))
		completePackage(packages[i], &registry, result);
}

private fn compilePackage(package: packageDescriptor, registry: packageRegistry*)
{
	let types = package.getAllTypes();
	for(i in enumerate(0, types.length()))
		createType(types[i], package, registry);
}

private fn completePackage(package: packageDescriptor, registry: packageRegistry*, cr: compilationResult) 
{
	let types = package.getAllTypes();
	for(i in enumerate(0, types.length()))
		completeType(types[i], package, registry, cr);
}

private fn createType(t: typeDescriptor, package: packageDescriptor, registry: packageRegistry*)
{
	let lt = registry.getLLVMTypeFor(t, package);
}

private fn completeType(t: typeDescriptor, package: packageDescriptor, registry: packageRegistry*, cr: compilationResult)
{
	if(t != typeof(usize))
	{
		let fields = t.fields();
		let lt = registry.getLLVMTypeFor(t, package);
		let types = <llvmType>[];
		for(i in enumerate(0, fields.length()))
		{
			let field = fields[i];
			types.push(registry.getLLVMTypeFor(field.type(), package));
		}
		lt.setFields(types);
		let cons = t.methods();
		for(i in enumerate(0, cons.length()))
		{
			let mod = registry.getModuleFor(cons[i]);
			createFunction(cons[i], package, registry, mod, cr);
		}
	}
}
