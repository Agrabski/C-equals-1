import {compilerEntryPoint packageDescriptor typeDescriptor functionDescriptor} from {cm1mLang::compiler}
import {usize string bool true false null} from {cm1mLang}
import {compilationResult llvmType llvmFunction llvmVoidType} from {cm1mLang::compiler::backend}
import {enumerate print dictionary list} from {std}

[compilerEntryPoint()]
public fn entryPoint(packages: packageDescriptor[], result: compilationResult) {
	let registry = packageRegistry(result);
	let processedPackages = list<packageDescriptor>();
	for(i in enumerate(0, packages.length()))
		compilePackage(packages[i], &registry, result, &processedPackages);}

private fn contains(l: list<packageDescriptor>*, elem: packageDescriptor*) -> bool
{
	for(i in enumerate(0, l.length()))
		if(l.get(i).name() == elem.name())
			return true();
	return false();
}

private fn compilePackage(package: packageDescriptor, registry: packageRegistry*, cr: compilationResult, processedPackages: list<packageDescriptor>*)
{
	if(contains(processedPackages, &package))
		return;
	print(package.name());
	let deps = package.dependencies();
	for(i in enumerate(0, deps.length()))
		compilePackage(deps[i], registry, cr, processedPackages);
	let functions = package.getAllFunctions();
	for(i in enumerate(0, functions.length()))
		if(functions[i].runtimeExecutable())
		{
			if(functions[i].isAbstract())
			{
				let name = functions[i].name();
				print("function " + name + " was ignored");
			}
			else
			{
				getFunction(functions[i], registry);
			}
		}
		
}


private fn getType(t: typeDescriptor, registry: packageRegistry*) -> llvmType
{
	if(t.isVoidType())
		return llvmVoidType(registry._compilationResult);
	let found = registry.findExistingType(t);
	if(found != null<llvmType>())
		return *found;
	print(t.qualifiedName());
	if(t.excludedAtRuntime())
		return;
	let lt = registry.getLLVMTypeFor(t);
	completeType(t, lt, registry);
	return lt;
}

private fn completeType(t: typeDescriptor, lType: llvmType, registry: packageRegistry*)
{
	if(t.isBasedOnGeneric())
	{
		let instantiationData = t.genericInstantiationInfo();
		if(instantiationData.generic() == genericTypeof(array))
			return;
	}
	if(t != typeof(usize) && (t != typeof(string)) && (t.referenceCount() == 0))
	{
		let fields = t.fields();
		let types = <llvmType>[];
		for(i in enumerate(0, fields.length()))
		{
			let field = fields[i];
			types.push(registry.getLLVMTypeFor(field.type()));
		}
		lType.setFields(types);
	}
}
