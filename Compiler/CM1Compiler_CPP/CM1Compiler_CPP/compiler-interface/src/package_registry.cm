import {compilerEntryPoint usize packageDescriptor string null array} from {cm1mLang}
import {llvmModule compilationResult llvmType llvmInt32Type llvmCstringType} from {cm1mLang::compiler::backend}
import {functionDescriptor typeDescriptor packageDescriptor} from {cm1mLang::compiler}
import {enumerate list print} from {std}

private struct pathPackagePair
{
	public path: string;
	public module: llvmModule;
	public fn construct(p: string, m:llvmModule)
	{
		self.path = p;
		self.module = m;
	}
}

private struct typeMapPair
{
	public ctype: typeDescriptor;
	public llvmType: llvmType;

	public fn construct(t: typeDescriptor, lt: llvmType)
	{
		self.ctype = t;
		self.llvmType = lt;
	}
}

private class packageRegistry
{
	private _data: list<pathPackagePair>;
	private _types: list<typeMapPair>;
	private _compilationResult: compilationResult;

	public fn construct(cr: compilationResult)
	{
		self._data = list<pathPackagePair>();
		self._types = list<typeMapPair>();
		self._compilationResult = cr;
	}

	private fn getModuleForFile(path: string) -> llvmModule
	{
		for(i in enumerate(0, self._data.length()))
			if(self._data.get(i).path == path)
				return self._data.get(i).module;
		let newModule = self._compilationResult.appendModule(path);
		let pair = pathPackagePair(path, newModule);
		self._data.push(pair);
		return newModule;

	}

	public fn getModuleFor(f: functionDescriptor) -> llvmModule
	{
		let file = f.sourceLocation();
		return self.getModuleForFile(file.filename);
	}

	public fn getLLVMTypeFor(t: typeDescriptor, package: packageDescriptor) -> llvmType
	{
		print(t.qualifiedName());
		if(t == typeof(usize))
			return llvmInt32Type(self._compilationResult);
		if(t == typeof(string))
			return llvmCstringType(self._compilationResult);
		let file = t.sourceLocation();
		let module = self.getModuleForFile(file.filename);
		for(i in enumerate(0, self._types.length()))
			if(self._types.get(i).ctype == t)
				return self._types.get(i).llvmType;
		let llvmType = self.translateType(t, module, package);
		self._types.push(typeMapPair(t, llvmType));
		return llvmType;
	}

	public fn getLLVMTypeForExisting(t: typeDescriptor) -> llvmType 
	{
		let file = t.sourceLocation();
		let module = self.getModuleForFile(file.filename);
		let baseType = t.baseType();
		if(baseType == typeof(usize))
			return llvmInt32Type(self._compilationResult);
		if(baseType == typeof(string))
			return llvmCstringType(self._compilationResult);

		let file = t.sourceLocation();
		let module = self.getModuleForFile(file.filename);
		for(i in enumerate(0, self._types.length()))
		{
			if(self._types.get(i).ctype == baseType)
			{
				return self.getType(t, self._types.get(i).llvmType, module);
			}
		}
		print(t.qualifiedName());
	}

	private fn getType(t: typeDescriptor, llvmBaseType: llvmType, module: llvmModule) -> llvmType
	{
		if(t.referenceCount() == 0)
			return llvmBaseType;
		return self.getType(t.dereference(), module.getPointer(llvmBaseType), module);
	}

	private fn translateType(t: typeDescriptor, module: llvmModule, package: packageDescriptor) -> llvmType
	{
		if(t.isBasedOnGeneric())
		{
			let instantiationData = t.genericInstantiationInfo();
			if(instantiationData.generic() == genericTypeof(array))
				return module.getPointer(self.getLLVMTypeFor(instantiationData.parameters()[0], package));
		}
		return module.appendStruct(package.name() + t.qualifiedName());
	}
}
