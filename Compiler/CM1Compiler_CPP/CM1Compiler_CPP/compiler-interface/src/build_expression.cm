import {
	IExpression
	llvmValue
	variableDescriptor
	variableReferenceExpression
	fieldAccessExpression
	functionCallExpression
	adressofExpression
	literalExpression
	constructorInvocationExpression
}
from {cm1mLang::compiler::ir}

import {llvmIrBodyBuilder llvmValue llvmFunction} from {cm1mLang::compiler::backend}
import {fieldDescriptor functionDescriptor} from {cm1mLang::compiler}
import {dictionary indexof print enumerate} from {std}
import {cast null usize string} from {cm1mLang}

private fn build_expression(instruction: IExpression*, builder: llvmIrBodyBuilder*, variables: dictionary<variableDescriptor, llvmValue>*, registry: packageRegistry*) -> llvmValue
{
	if(cast<variableReferenceExpression, IExpression>(instruction) != null<variableReferenceExpression>())
		return build(
			cast<variableReferenceExpression, IExpression>(instruction),
			builder,
			variables,
			registry
		);
	if(cast<fieldAccessExpression, IExpression>(instruction) != null<fieldAccessExpression>())
		return build(
			cast<fieldAccessExpression, IExpression>(instruction),
			builder,
			variables,
			registry
		);
	if(cast<functionCallExpression, IExpression>(instruction) != null<functionCallExpression>())
		return build(
			cast<functionCallExpression, IExpression>(instruction),
			builder,
			variables,
			registry
		);
	if(cast<adressofExpression, IExpression>(instruction) != null<adressofExpression>())
		return build(
			cast<adressofExpression, IExpression>(instruction),
			builder,
			variables,
			registry
		);
	if(cast<literalExpression, IExpression>(instruction) != null<literalExpression>())
		return build(
			cast<literalExpression, IExpression>(instruction),
			builder,
			variables,
			registry
		);
	if(cast<constructorInvocationExpression, IExpression>(instruction) != null<constructorInvocationExpression>())
		return build(
			cast<constructorInvocationExpression, IExpression>(instruction),
			builder,
			variables,
			registry
		);
	print<IExpression*>(instruction);
}

private fn build(instruction: functionCallExpression*, builder: llvmIrBodyBuilder*, variables: dictionary<variableDescriptor, llvmValue>*, registry: packageRegistry*) -> llvmValue
{
	let f = instruction._runtimeFunction;
	let values = <llvmValue>[];
	let arguments = instruction._arguments;
	for(i in enumerate(0, arguments.length()))
	{
		print<IExpression*>(arguments[i]);
		values.push(build_expression(
			arguments[i],
			builder,
			variables,
			registry
		));
	}
	return builder.appendFunctionCall(getFunction(f, registry), &values);
}

private fn build(instruction: constructorInvocationExpression*, builder: llvmIrBodyBuilder*, variables: dictionary<variableDescriptor, llvmValue>*, registry: packageRegistry*) -> llvmValue
{
	let f = instruction._runtimeConstructor;
	let values = <llvmValue>[];
	let arguments = instruction._arguments;
	let self = builder.appendAlloca(getType(instruction.type(), registry));
	values.push(self);
	for(i in enumerate(0, arguments.length()))
	{
		print<IExpression*>(arguments[i]);
		values.push(build_expression(
			arguments[i],
			builder,
			variables,
			registry
		));
	}
	builder.appendFunctionCall(getFunction(f, registry), &values);
	return self;
}

private fn build(instruction: variableReferenceExpression*, builder: llvmIrBodyBuilder*, variables: dictionary<variableDescriptor, llvmValue>*, registry: packageRegistry*) -> llvmValue
{
	return *(variables.get(instruction._variable));
}

private fn build(instruction: literalExpression*, builder: llvmIrBodyBuilder*, variables: dictionary<variableDescriptor, llvmValue>*, registry: packageRegistry*) -> llvmValue
{
	if(instruction.type() == typeof(usize))
		return builder.appendIntegerLiteral(
			*cast<usize, void>(instruction._value),
			getType(instruction.type(), registry)
		);
	print<literalExpression*>(instruction);
}

private fn build(instruction: fieldAccessExpression*, builder: llvmIrBodyBuilder*, variables: dictionary<variableDescriptor, llvmValue>*, registry: packageRegistry*) -> llvmValue
{
	let field = instruction._field;
	let exp = instruction._expression;
	let val = build_expression(exp, builder, variables, registry);
	let typeFields = field.parent().fields();
	let llvmBaseType = getType(field.parent(), registry);
	return builder.apendGetElementPointer(
		val,
		0,
		indexof<fieldDescriptor>(&typeFields, &field),
		llvmBaseType
	);
}

private fn build(instruction: adressofExpression*, builder: llvmIrBodyBuilder*, variables: dictionary<variableDescriptor, llvmValue>*, registry: packageRegistry*) -> llvmValue
{
	let exp = build_expression(instruction._expression, builder, variables, registry);
	if(exp.referenceCount() == (instruction.type().referenceCount()) && (instruction.type() != typeof(string).reference()))
	{
		print("skip");
		return exp;
	}
	let add = builder.appendAlloca(getType(instruction.type().dereference(), registry));
	builder.appendStore(exp, add);
	return add;
}